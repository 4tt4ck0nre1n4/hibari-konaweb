---
import Layout from "../layouts/Layout.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import Logo from "../components/Logo.astro";
import Breadcrumbs from "../components/Breadcrumbs.astro";
import Aside from "../components/Aside.astro";
import SwiperMenu from "../components/SwiperMenu.astro";
import globalText from "../data/globalText.json";
import SwiperDisplay from "../components/SwiperDisplay.astro";
import gridBackgroundImageSrc from "../assets/gridBackground.webp";
import { getImage } from "astro:assets";
import FirstView from "../components/FirstView.astro";
import GridMenu from "../components/GridMenu.astro";
import ControlMenu from "../components/ControlMenu.astro";
import fvBackgroundImageSrc from "../assets/fvBackgroundImage.webp";
import fvAnimeImageSrc from "../assets/fvAnimeImage.webp";

const gridBackgroundImage = await getImage({ src: gridBackgroundImageSrc });
// LCP最適化: FirstViewの背景画像を最優先でプリロード
// qualityを75に下げてファイルサイズを削減（リソース読み込み時間の短縮）
const fvBackgroundImage = await getImage({
  src: fvBackgroundImageSrc,
  width: 1920,
  height: 1080,
  quality: 75,
  format: "webp",
});
const fvAnimeImage = await getImage({
  src: fvAnimeImageSrc,
  width: 1920,
  quality: 80,
  format: "webp",
});
---

<Layout
  title={globalText.top.title}
  description={globalText.top.description}
  ogType={globalText.og.type}
  ogTitle={globalText.top.title}
  ogDescription={globalText.top.description}
  twitterTitle={globalText.top.title}
  twitterDescription={globalText.top.description}
>
  <!-- LCP背景画像のプリロード（HeadLayoutのheadの最初に配置） -->
  <link
    slot="lcp-preload"
    rel="preload"
    href={fvBackgroundImage.src}
    as="image"
    fetchpriority="high"
    type="image/webp"
  />
  <link slot="lcp-preload" rel="preload" href={fvAnimeImage.src} as="image" fetchpriority="low" type="image/webp" />
  <!-- その他の画像のプリロード -->
  <link slot="head" rel="preload" href={gridBackgroundImage.src} as="image" fetchpriority="low" type="image/webp" />

  <div id="outer-container">
    <Header />
    <main id="page-wrap">
      <Logo />
      <div class="breadcrumbs__wrapper breadcrumbs__wrapper_top">
        <Breadcrumbs crumbs={[]} />
      </div>
      <FirstView fvBackgroundImageSrc={fvBackgroundImage.src} fvAnimeImageSrc={fvAnimeImage.src} />
      <div class="swiper-display-container">
        <SwiperDisplay />
      </div>
      <div id="main-background" class="main-background" style={`background-image: url(${gridBackgroundImage.src})`}>
        <div class="main-content__wrapper">
          <aside class="toolbar">
            <Aside />
          </aside>
          <div id="js-grid" class="grid">
            <div class="wrapper">
              <GridMenu />
              <ControlMenu />
            </div>
          </div>
          <div class="sidebar">
            <SwiperMenu />
          </div>
        </div>
      </div>
    </main>
    <Footer />
    <canvas id="canvas" class="canvas" width="800" height="600"></canvas>
  </div>
</Layout>

<style is:global>
  /* 背景画像用コンテナ */
  #main-background.main-background {
    min-height: 600px; /* CLSを防ぐために最小高さを設定 */
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
    padding-block: 2rem;
    padding-inline: 1rem; /* 768px以上の画面幅で両端にパディングを設定 */
    z-index: 1;
  }

  /* レイアウト用コンテナ */
  .main-content__wrapper {
    width: 100%;
    max-width: 1400px;
    margin-inline: auto;
    display: grid;
    grid-template-columns: 24% 50% 24%;
    gap: 1%;
    align-items: stretch; /* すべてのカラムを同じ高さに */
    height: 100%;
  }

  .toolbar {
    min-height: 400px; /* CLSを防ぐために最小高さを設定 */
  }

  .sidebar {
    min-height: 400px; /* CLSを防ぐために最小高さを設定 */
  }
  .swiper-display-container {
    display: block;
    width: 100%;
    margin-bottom: 0.5rem;
  }

  /* タブレット・スマホサイズでのレスポンシブ対応 */
  @media (width <= 1024px) {
    #main-background.main-background {
      padding-block: 1rem;
      padding-inline: 1rem;
      min-height: auto;
      z-index: 1; /* tsParticlesより上に表示 */
    }

    .main-content__wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .toolbar {
      order: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      min-height: auto;
    }

    .grid {
      order: 3;
      width: 100%;
      height: auto;
      min-height: auto;
    }

    .sidebar {
      order: 2;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: auto;
    }
  }

  /* 480px以下での超小型スマホ最適化 */
  @media (width <= 480px) {
    #main-background.main-background {
      padding-inline: 0.5rem;
      min-height: auto;
    }

    .main-content__wrapper {
      gap: 0.5rem;
    }

    .toolbar {
      grid-template-columns: 1fr;
      gap: 0.25rem;
      min-height: auto;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      margin-block-end: 0;
      gap: 0.35rem;
      min-height: auto;
    }

    .grid {
      margin-block-start: 1rem; /* スマホサイズでの余白調整 */
    }
  }
  #main-background.main-background.is-notImage {
    background-image: none !important;
    background-color: transparent !important;
  }
  .main-background.is-notImage {
    transition: background 2s ease-in-out;
  }
  .toolbar {
    /* grid-area: 1 / 1 / 2 / 2; */
    /* grid-area: 1 / 1 / 1 / 1; */
    display: flex;
    flex-direction: column;
    row-gap: 0.75rem;
    color: inherit;
    position: relative;
  }
  .grid {
    grid-area: 1 / 2 / 2 / 3;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    background-color: transparent;
    transition:
      5s height ease-out,
      5s opacity ease-out;
  }
  .canvas {
    width: 100%;
    height: 100%;
    background-color: transparent;
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 9999;
    /* レイアウトシフト防止: 初期サイズを明示的に設定 */
    min-width: 100vw;
    min-height: 100vh;
  }

  /* タブレットサイズでのcanvas最適化 */
  @media (width <= 1024px) and (width > 768px) {
    .canvas {
      min-width: 1024px;
      min-height: 768px;
    }
  }

  /* スマホサイズでのcanvas最適化 */
  @media (width <= 768px) {
    .canvas {
      min-width: 100vw;
      min-height: 100vh;
      /* スマホのアドレスバー表示/非表示に対応 */
      min-height: -webkit-fill-available;
    }
  }

  /* 超小型スマホサイズでのcanvas最適化 */
  @media (width <= 480px) {
    .canvas {
      min-width: 100vw;
      min-height: 100vh;
      /* スマホのアドレスバー表示/非表示に対応 */
      min-height: -webkit-fill-available;
    }
  }
  .wrapper {
    width: 100%;
    max-width: 700px;
    margin-inline: auto;
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 1rem;
    justify-content: flex-start;
  }

  .sidebar {
    grid-area: 1 / 3 / 2 / 4;
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  #tsparticles {
    width: 100%;
    height: 500px;
    display: block;
    /* クリックイベントを透過して、ボタンがクリック可能になるようにする */
    pointer-events: none;
  }

  /* すべてのボタンにpointer-events: autoを設定してクリック可能にする */
  /* tsParticlesが全画面を覆っても、ボタンがクリック可能になるようにする */
  button,
  #toggleBackgroundButton,
  #clockIcon,
  #toggleLogoSvgButton,
  .particlesButton,
  #confettiButton,
  .particlesButton__inner,
  .tools__wrapper,
  .particles__wrapper {
    pointer-events: auto;
    position: relative;
    z-index: 10; /* tsParticles（z-index: 2）より上に表示 */
  }

  /* tsParticlesコンテナ自体はpointer-events: noneだが、その中のボタンはクリック可能 */
  .particles__inner {
    pointer-events: none;
  }

  .particles__inner > * {
    pointer-events: auto;
  }
</style>

<!-- 開発環境フラグを設定（ビルド時に置換される） -->
<script is:inline define:vars={{ isDev: import.meta.env.DEV }}>
  // @ts-nocheck
  // 開発環境判定（Astroのビルド時に置換される）
  window.__DEV__ = isDev;
</script>

<!-- ネットワーク依存関係ツリー最適化: 非クリティカルJavaScriptの遅延読み込み強化 -->
<!-- TBT改善: 動的インポートでモジュール読み込みを遅延させ、requestIdleCallbackで初期化 -->
<script>
  // GSAPを動的インポートで読み込み（未使用JavaScript削減のため）
  async function loadGSAP() {
    if (typeof window !== "undefined" && typeof (window as Window & { gsap?: unknown }).gsap === "undefined") {
      const [{ gsap }, { ScrollTrigger }] = await Promise.all([import("gsap"), import("gsap/ScrollTrigger")]);

      // グローバル変数に設定（gridControlAnimations.tsが期待している形式）
      (window as Window & { gsap?: typeof gsap; ScrollTrigger?: typeof ScrollTrigger }).gsap = gsap;
      (window as Window & { gsap?: typeof gsap; ScrollTrigger?: typeof ScrollTrigger }).ScrollTrigger = ScrollTrigger;

      // GSAPプラグインを登録
      gsap.registerPlugin(ScrollTrigger);
    }
  }

  // 動的インポートでモジュール読み込みを遅延（ネットワーク依存関係ツリー最適化）
  // より積極的な遅延: requestIdleCallbackのタイムアウトを延長し、初期読み込みをブロックしない
  function loadGridControlAnimations() {
    if ("requestIdleCallback" in window) {
      requestIdleCallback(
        async () => {
          // GSAPを先に読み込む
          await loadGSAP();
          const { initGridControlAnimationsDeferred } = await import("../scripts/gridControlAnimations");
          initGridControlAnimationsDeferred();
        },
        { timeout: 5000 } // タイムアウトを延長（2秒→5秒）してクリティカルパスへの影響を最小化
      );
    } else {
      // フォールバック: より長い遅延でクリティカルパスをブロックしない
      setTimeout(async () => {
        // GSAPを先に読み込む
        await loadGSAP();
        const { initGridControlAnimationsDeferred } = await import("../scripts/gridControlAnimations");
        initGridControlAnimationsDeferred();
      }, 2000); // 100ms→2000msに延長して初期読み込みをブロックしない
    }
  }

  // ネットワーク依存関係ツリー最適化: DOMContentLoadedを待たずに、より積極的に遅延
  // ページの初期表示をブロックしないため、即座にスケジュールする
  if (document.readyState === "loading") {
    // 読み込み中の場合も即座にスケジュール（DOMContentLoadedを待たない）
    loadGridControlAnimations();
  } else {
    loadGridControlAnimations();
  }

  // View Transitions対応: ページ遷移時に再初期化
  document.addEventListener("astro:after-swap", () => {
    loadGridControlAnimations();
  });
</script>

<!-- ネットワーク依存関係ツリー最適化: 非クリティカルJavaScriptの遅延読み込み強化 -->
<!-- TBT改善: 動的インポートでモジュール読み込みを遅延させ、requestIdleCallbackで初期化 -->
<script>
  // 動的インポートでモジュール読み込みを遅延（ネットワーク依存関係ツリー最適化）
  // より積極的な遅延: requestIdleCallbackのタイムアウトを延長し、初期読み込みをブロックしない
  function loadConfetti() {
    if ("requestIdleCallback" in window) {
      requestIdleCallback(
        async () => {
          const { initConfettiDeferred } = await import("../scripts/confetti");
          initConfettiDeferred();
        },
        { timeout: 5000 } // タイムアウトを延長（2秒→5秒）してクリティカルパスへの影響を最小化
      );
    } else {
      // フォールバック: より長い遅延でクリティカルパスをブロックしない
      setTimeout(async () => {
        const { initConfettiDeferred } = await import("../scripts/confetti");
        initConfettiDeferred();
      }, 2000); // 100ms→2000msに延長して初期読み込みをブロックしない
    }
  }

  // ネットワーク依存関係ツリー最適化: DOMContentLoadedを待たずに、より積極的に遅延
  // ページの初期表示をブロックしないため、即座にスケジュールする
  if (document.readyState === "loading") {
    // 読み込み中の場合も即座にスケジュール（DOMContentLoadedを待たない）
    loadConfetti();
  } else {
    loadConfetti();
  }
</script>
