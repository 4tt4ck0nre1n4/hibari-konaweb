---
import RiveComponent from "./RiveComponent.tsx";

interface CardProps {
  href: string;
  ariaLabel: string;
  ariaTitle: string;
  cardTitle: string;
  cardBody: string;
  cardDetails: string;
  serviceMenu?: Array<{ item: string }>;
  src: string;
  stateMachines?: string | string[];
}

const { href, ariaLabel, ariaTitle, cardTitle, cardBody, cardDetails, serviceMenu, src, stateMachines } =
  Astro.props as CardProps;
---

<li class="card__item">
  <article class="card__article">
    <div class="card__flip-container">
      <!-- 表面 -->
      <div class="card__front">
        <a class="card__item_link" href={href} aria-label={ariaLabel} title={ariaTitle}>
          <h2 class="card__item_header">
            {cardTitle}
            <span class="card__flip_arrow" aria-hidden="true" title="詳細を見る">
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M5 12h14"></path>
                <path d="M12 5l7 7-7 7"></path>
              </svg>
            </span>
          </h2>
          <p class="card__item_body">
            {cardBody}
          </p>
          <figure class="card__item_image">
            <RiveComponent src={src} stateMachines={stateMachines} minWidth={300} minHeight={200} client:only="react" />
          </figure>
        </a>
      </div>

      <!-- 裏面 -->
      <div class="card__back">
        <div class="card__back_content">
          <h2 class="card__back_header">
            {cardTitle}
          </h2>
          <ul class="card__back_details">
            {
              Array.isArray(serviceMenu) ? (
                serviceMenu.map((menuItem: { item: string }) => (
                  <li class="card__back_details_item">{menuItem.item}</li>
                ))
              ) : typeof cardDetails === "string" ? (
                <li class="card__back_details_item">{cardDetails}</li>
              ) : null
            }
          </ul>
          <!-- <p class="card__back_body">
          {cardDetails}
        </p> -->
          <!-- <div class="card__back_details">
          <p>詳細情報がここに表示されます</p>
          <p>カードの裏面です</p>
        </div> -->
          <button class="card__flip_back" type="button">&larr;</button>
        </div>
        <!-- 裏面全体をクリック可能にするためのオーバーレイ -->
        <div class="card__back_overlay"></div>
      </div>
    </div>
  </article>
</li>

<style>
  .card__item {
    display: flex;
    border-radius: 0.5rem;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 8px rgba(0 0 0 / 0.6);
    background-image: none;
    background-size: 500%;
    background-position: 100%;
    transition: background-position 0.6s cubic-bezier(0.22, 1, 0.36, 1);
    padding: 1px;
    perspective: 1000px;
    min-height: 500px;
    height: 100%;
  }

  .card__flip-container {
    position: relative;
    width: 100%;
    height: 100%;
    min-height: 500px;
    transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    /* iOS Safari対応: ハードウェアアクセラレーション */
    -webkit-transform-style: preserve-3d;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
  }

  .card__flip-container.flipped {
    transform: rotateY(180deg);
  }

  .card__front,
  .card__back {
    position: absolute;
    width: 100%;
    height: 100%;
    min-height: 500px;
    backface-visibility: hidden;
    border-radius: 8px;
    /* iOS Safari対応: 3D変換の最適化 */
    -webkit-backface-visibility: hidden;
    -webkit-transform-style: preserve-3d;
    transform-style: preserve-3d;
  }

  /* 表面のスタイル（常に前面に表示） */
  .card__front {
    z-index: 2;
    /* タッチ操作を確実にする */
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* 裏面のスタイル */
  .card__back {
    transform: rotateY(180deg);
    /* iOS Safari対応: 裏面の表示を確実に隠す */
    -webkit-transform: rotateY(180deg);
    z-index: 1;
    /* タッチ操作を確実にする */
    cursor: pointer;
    pointer-events: auto;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* フリップ時のz-index調整 */
  .card__flip-container.flipped .card__front {
    z-index: 1;
  }

  .card__flip-container.flipped .card__back {
    z-index: 2;
  }

  /* モバイルデバイス用のシンプルなアプローチ */
  @media screen and (max-width: 768px) {
    .card__flip-container {
      transform-style: preserve-3d;
      -webkit-transform-style: preserve-3d;
    }

    .card__front,
    .card__back {
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-style: preserve-3d;
      -webkit-transform-style: preserve-3d;
      /* iPhoneでの重複表示を防ぐため、より強力な設定 */
      isolation: isolate;
      -webkit-isolation: isolate;
    }

    .card__back {
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg);
    }

    .card__flip-container.flipped {
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg);
    }

    /* iPhone Safari専用の追加修正 */
    @supports (-webkit-touch-callout: none) {
      .card__front,
      .card__back {
        backface-visibility: hidden !important;
        -webkit-backface-visibility: hidden !important;
        transform-style: preserve-3d !important;
        -webkit-transform-style: preserve-3d !important;
        /* より強力な重複防止 */
        contain: layout style paint;
        -webkit-contain: layout style paint;
      }

      /* 表面と裏面のz-indexを確実に設定 */
      .card__front {
        z-index: 2 !important;
      }

      .card__back {
        z-index: 1 !important;
      }

      .card__flip-container.flipped .card__front {
        z-index: 1 !important;
      }

      .card__flip-container.flipped .card__back {
        z-index: 2 !important;
      }
    }
  }
  .card__item_link {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.6;
    color: inherit;
    background-color: #232323;
    background-color: transparent;
    /* background-color: #23262d; */
    text-decoration: none;
    border-radius: 8px;
    opacity: 0.8;
    padding: calc(1.5rem - 1px);
    overflow: hidden;
  }
  .card__article {
    width: 100%;
    height: 100%;
  }

  .card__item_header {
    font-size: 1.125rem;
    border-bottom: rebeccapurple 1px solid;
    transition: color 0.6s cubic-bezier(0.22, 1, 0.36, 1);
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
  }

  .card__flip_arrow {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, rebeccapurple 0%, #8a2be2 100%);
    border-radius: 50%;
    color: white;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(102, 51, 153, 0.3);
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
  }

  .card__flip_arrow::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
  }

  .card__flip_arrow:hover::before {
    left: 100%;
  }

  .card__flip_arrow svg {
    width: 16px;
    height: 16px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .card__flip_arrow:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(102, 51, 153, 0.4);
    background: linear-gradient(135deg, #8a2be2 0%, rebeccapurple 100%);
  }

  .card__flip_arrow:hover svg {
    transform: translateX(2px);
  }

  .card__item:is(:hover, :focus-visible) .card__flip_arrow {
    background: linear-gradient(135deg, rgb(var(--accent-light)) 0%, #8a2be2 100%);
    box-shadow: 0 4px 16px rgba(102, 51, 153, 0.5);
  }
  .card__item_body {
    font-size: 0.9375rem;
    line-height: 1.8;
    letter-spacing: 0.04em;
    text-align: justify;
    margin-block: 1rem;
    flex-grow: 1;
    display: flex;
    align-items: center;
  }
  .card__item:is(:hover, :focus-visible) {
    background-color: transparent;
    box-shadow: 0 10px 10px rgba(0 0 0 / 0.6);
    background-position: 0;
    background-image: linear-gradient(
      45deg,
      rgba(238, 161, 255, 1),
      #ffffff71,
      rgba(147, 183, 255, 1),
      #ffffff71,
      rgba(170, 244, 254, 1)
    );
  }
  html.dark .card__item {
    box-shadow: 0 4px 8px rgba(255 255 255 / 0.6);
  }
  html.dark .card__item:is(:hover, :focus-visible) {
    box-shadow: 0 10px 10px rgba(0 0 0 / 0.6);
    background-position: 0;
    background-image: linear-gradient(45deg, #ffffff71, transparent, #ffffff71, transparent, #ffffff71);
  }

  html.dark .card__flip_arrow {
    background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);
    box-shadow: 0 2px 8px rgba(168, 85, 247, 0.4);
  }

  html.dark .card__flip_arrow:hover {
    background: linear-gradient(135deg, #9333ea 0%, #a855f7 100%);
    box-shadow: 0 4px 12px rgba(168, 85, 247, 0.5);
  }

  html.dark .card__item:is(:hover, :focus-visible) .card__flip_arrow {
    background: linear-gradient(135deg, #c084fc 0%, #a855f7 100%);
    box-shadow: 0 4px 16px rgba(168, 85, 247, 0.6);
  }
  .card__item:is(:hover, :focus-visible) .card__item_header {
    color: rgb(var(--accent-light));
    color: rebeccapurple;
  }
  .card__item_image {
    width: 100%;
    max-width: 300px;
    height: auto;
    max-height: 200px;
    object-fit: contain;
    margin-block-start: auto;
    flex-shrink: 0;
  }

  .rive-container {
    width: 100%;
    max-width: 300px;
    height: auto;
    max-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .rive-component {
    width: 100%;
    height: 100%;
    max-height: 200px;
  }

  .rive-component canvas {
    width: 100% !important;
    height: 100% !important;
    max-height: 200px !important;
    max-width: 300px !important;
    object-fit: contain !important;
    display: block;
  }

  .rive-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 300px;
    height: auto;
    max-height: 200px;
    min-height: 150px;
  }

  .rive-loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid rebeccapurple;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  /* 裏面のスタイリング */
  .card__back_content {
    width: 100%;
    height: 100%;
    min-height: 500px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(135deg, rgba(102, 51, 153, 0.1) 0%, rgba(102, 51, 153, 0.05) 100%);
    border: 1px solid rgba(102, 51, 153, 0.2);
    border-radius: 0.5rem;
    position: relative;
    overflow: hidden;
    padding-block: 1rem;
    padding-inline: 0.5rem;
  }

  .card__back_content::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 30%, rgba(102, 51, 153, 0.03) 50%, transparent 70%);
    pointer-events: none;
  }

  .card__back_header {
    font-size: 1.125rem;
    font-weight: bold;
    /* color: rgb(102, 51, 153); */
    text-align: center;
    /* margin-bottom: 1.5rem; */
    /* padding-bottom: 0.75rem; */
    border-bottom: 2px solid rgba(102, 51, 153, 0.3);
    position: relative;
    z-index: 1;
    padding-block-end: 0.5rem;
  }

  .card__back_body {
    font-size: 0.9375rem;
    line-height: 1.6;
    letter-spacing: 0.02em;
    text-align: center;
    margin-bottom: 1.5rem;
    color: rgba(102, 51, 153, 0.8);
    flex-grow: 1;
    display: flex;
    align-items: center;
    position: relative;
    z-index: 1;
  }

  .card__back_details {
    width: 100%;
    max-width: 288px;
    /* margin-block-start: 1rem; */
    padding-block-start: 1rem;
    position: relative;
    z-index: 1;
  }

  .card__back_details_item {
    font-size: 0.9375rem;
    line-height: 1.4;
    background: rgba(102, 51, 153, 0.08);
    color: rgb(102, 51, 153);
    margin-block-start: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    border-left: 3px solid rgb(102, 51, 153);
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(102, 51, 153, 0.1);
  }

  .card__back_details_item:hover {
    background: rgba(102, 51, 153, 0.12);
    transform: translateX(2px);
    box-shadow: 0 4px 8px rgba(102, 51, 153, 0.15);
  }

  .card__back_details_item:last-child {
    margin-bottom: 0;
  }

  html.dark .card__back_details_item {
    color: #ffffff;
  }

  .card__back_details p {
    margin: 0;
    color: inherit;
  }

  .card__flip_back {
    min-width: 120px;
    background: linear-gradient(135deg, rgb(102, 51, 153) 0%, rgb(120, 70, 180) 100%);
    color: white;
    border: none;
    border-radius: 0.5rem;
    margin-block-start: 0.5rem;
    padding: 0.25rem 2rem;
    font-size: 1.25rem;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(102, 51, 153, 0.3);
    position: relative;
    z-index: 1;
  }

  .card__flip_back:hover {
    background: linear-gradient(135deg, rgb(120, 70, 180) 0%, rgb(102, 51, 153) 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(102, 51, 153, 0.4);
  }

  .card__flip_back:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(102, 51, 153, 0.3);
  }

  /* 裏面オーバーレイ（タッチ操作用） */
  .card__back_overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
    cursor: pointer;
    /* 透明だがタッチ可能 */
    background: transparent;
    /* タッチイベントを確実に有効にする */
    pointer-events: auto;
    /* iOS Safariでのタッチ最適化 */
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    /* タッチ領域を拡大 */
    min-width: 44px;
    min-height: 44px;
    /* デバッグ用：一時的に背景色を追加 */
    background: rgba(0, 255, 0, 0.2);
  }

  /* モバイルデバイスでのオーバーレイ最適化 */
  @media screen and (max-width: 768px) {
    .card__back_overlay {
      /* タッチ操作を確実にする */
      touch-action: manipulation;
      pointer-events: auto;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      /* デバッグ用：一時的に背景色を追加（後で削除） */
      /* background: rgba(255, 0, 0, 0.3); */
      /* border: 2px solid red; */
    }
  }
</style>

<script>
  // @ts-nocheck
  import { gsap } from "gsap";

  // カードのフリップアニメーションを初期化
  function initCardFlip() {
    const cards = document.querySelectorAll(".card__item");

    cards.forEach((card) => {
      const flipContainer = card.querySelector(".card__flip-container");
      const frontLink = card.querySelector(".card__front .card__item_link");
      const backButton = card.querySelector(".card__flip_back");
      const backOverlay = card.querySelector(".card__back_overlay");
      const backFace = card.querySelector(".card__back");

      // フリップ状態を管理するフラグ
      let isFlipping = false;
      let isCurrentlyShowingBack = false; // 現在裏面が表示されているかの状態
      let flipState = false; // 追加のフリップ状態管理
      let touchStartTime = 0;
      let touchStartY = 0;

      // フリップ状態を更新する関数
      const updateFlipState = (flipped: boolean) => {
        console.log("iPhone Debug - Updating flip state from", isFlipping, "to", flipped);
        isFlipping = flipped;
      };

      // 現在のフリップ状態を確認する関数（改良版）
      const isCurrentlyFlipped = () => {
        // 最もシンプルで確実な方法：内部状態を使用
        console.log("iPhone Debug - Using internal state - isCurrentlyShowingBack:", isCurrentlyShowingBack);
        return isCurrentlyShowingBack;
      };

      // フリップ状態をリセットする関数
      const resetFlipState = () => {
        console.log("iPhone Debug - Resetting flip state");
        isFlipping = false;
      };

      // 表面のクリック/タッチ処理（統一されたイベントハンドリング）
      const handleFrontInteraction = (e: Event) => {
        console.log(
          "iPhone Debug - Front interaction detected, isFlipping:",
          isFlipping,
          "isCurrentlyFlipped:",
          isCurrentlyFlipped()
        );
        e.preventDefault();
        e.stopPropagation();

        // フリップ中は処理をスキップ
        if (isFlipping) {
          console.log("iPhone Debug - Skipping front flip - already flipping");
          return;
        }

        // 現在裏面が表示されている場合は表面に戻る
        // DOMの状態を少し遅延させて確認（非同期更新の問題を回避）
        setTimeout(() => {
          const currentlyFlipped = isCurrentlyFlipped();
          console.log("iPhone Debug - Final flip decision (delayed) - currentlyFlipped:", currentlyFlipped);

          if (currentlyFlipped) {
            console.log("iPhone Debug - Currently showing back, flipping to front");
            isFlipping = true;
            flipCard(flipContainer as HTMLElement, false, resetFlipState);
          } else {
            // 現在表面が表示されている場合は裏面にフリップ
            console.log("iPhone Debug - Currently showing front, flipping to back");
            isFlipping = true;
            flipCard(flipContainer as HTMLElement, true, resetFlipState);
          }
        }, 10);
      };

      // 裏面の戻るボタン処理
      const handleBackClick = (e: Event) => {
        console.log("iPhone Debug - Back button clicked, isFlipping:", isFlipping);
        console.log("iPhone Debug - handleBackClick called from:", e.target);
        e.preventDefault();
        e.stopPropagation();

        // フリップ中は処理をスキップ
        if (isFlipping) {
          console.log("iPhone Debug - Skipping back flip - already flipping");
          return;
        }

        // 重複実行防止のためのタイムアウト
        const now = Date.now();
        if (typeof handleBackClick.lastExecutionTime === "undefined") {
          handleBackClick.lastExecutionTime = 0;
        }

        if (now - handleBackClick.lastExecutionTime < 100) {
          console.log("iPhone Debug - Skipping back flip - too soon after last execution");
          return;
        }

        handleBackClick.lastExecutionTime = now;

        // フリップ状態を一時的に設定
        isFlipping = true;
        console.log("iPhone Debug - Calling flipCard with false (to front)");
        flipCard(flipContainer as HTMLElement, false, resetFlipState);
      };

      // デバイス検出の改善（iPhone対応強化）
      const isTouchDevice =
        "ontouchstart" in window ||
        navigator.maxTouchPoints > 0 ||
        /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
        /Mobile|Tablet/i.test(navigator.userAgent) ||
        window.innerWidth <= 768 ||
        // iPhone Safari特有の検出
        (/Safari/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)) ||
        // iOS WebKit特有の検出
        (/WebKit/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)) ||
        // その他のモバイルデバイス検出
        typeof window.DeviceMotionEvent !== "undefined" ||
        // タッチイベントサポートの詳細チェック
        window.TouchEvent !== undefined ||
        window.ontouchstart !== undefined;

      console.log("iPhone Debug - Device detection:", {
        ontouchstart: "ontouchstart" in window,
        maxTouchPoints: navigator.maxTouchPoints,
        userAgent: navigator.userAgent,
        isTouchDevice: isTouchDevice,
        windowWidth: window.innerWidth,
        // 追加の検出情報
        isIOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),
        isSafari: /Safari/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent),
        isWebKit: /WebKit/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent),
        hasDeviceMotion: typeof window.DeviceMotionEvent !== "undefined",
        hasTouchEvent: window.TouchEvent !== undefined,
      });

      // 表面のイベント設定（タッチとクリック両方）
      console.log("iPhone Debug - Setting up events for front link, isTouchDevice:", isTouchDevice);
      console.log("iPhone Debug - Front link element:", frontLink);

      // タッチイベント（タッチデバイスの場合）
      if (isTouchDevice) {
        // タッチスタート（簡素化版）
        frontLink?.addEventListener(
          "touchstart",
          (e) => {
            console.log("iPhone Debug - Front link touch start detected (simplified)");
            touchStartTime = Date.now();
            console.log("iPhone Debug - Touch start time:", touchStartTime);
          },
          { passive: true, capture: false }
        );

        // タッチエンド
        frontLink?.addEventListener(
          "touchend",
          (e) => {
            console.log("iPhone Debug - Front link touch end detected (simplified)");

            // 基本的なタッチ検証のみ
            const touchDuration = Date.now() - touchStartTime;
            console.log("iPhone Debug - Touch duration:", touchDuration);

            // 極端に長いタッチ（10秒以上）以外は全て有効とする
            if (touchDuration < 10000) {
              console.log("iPhone Debug - Valid touch, calling handleFrontInteraction");
              handleFrontInteraction(e);
            } else {
              console.log("iPhone Debug - Touch too long, ignoring");
            }
          },
          { passive: false, capture: false }
        );

        // タッチキャンセル（簡素化版）
        frontLink?.addEventListener(
          "touchcancel",
          (e) => {
            console.log("iPhone Debug - Front link touch cancelled (simplified)");
          },
          { passive: true, capture: false }
        );
      }

      // クリックイベント（全てのデバイスで設定）
      frontLink?.addEventListener("click", (e) => {
        console.log("iPhone Debug - Click event detected on front link");
        console.log("iPhone Debug - Click event - preventing default and stopping propagation");
        e.preventDefault();
        e.stopPropagation();
        handleFrontInteraction(e);
      });

      // 裏面ボタンのイベント設定（タッチとクリック両方）
      console.log("iPhone Debug - Setting up events for back button, isTouchDevice:", isTouchDevice);

      // タッチイベント（タッチデバイスの場合）
      if (isTouchDevice) {
        // タッチデバイス用の裏面ボタン処理
        let backTouchStartTime = 0;

        backButton?.addEventListener(
          "touchstart",
          () => {
            console.log("iPhone Debug - Back button touch start");
            backTouchStartTime = Date.now();
          },
          { passive: true }
        );

        backButton?.addEventListener(
          "touchend",
          (e) => {
            const touchDuration = Date.now() - backTouchStartTime;
            console.log("iPhone Debug - Back button touch end, duration:", touchDuration);

            if (touchDuration < 300) {
              console.log("iPhone Debug - Valid back button tap, calling handleBackClick");
              handleBackClick(e);
            } else {
              console.log("iPhone Debug - Invalid back button tap (too long), ignoring");
            }
          },
          { passive: false }
        );
      }

      // クリックイベント（全てのデバイスで設定）
      backButton?.addEventListener("click", (e) => {
        console.log("iPhone Debug - Click event detected on back button");
        handleBackClick(e);
      });

      // 裏面オーバーレイのイベント設定（裏面全体をタッチ可能にする）
      console.log("iPhone Debug - Setting up events for back overlay, isTouchDevice:", isTouchDevice);
      console.log("iPhone Debug - Back overlay element:", backOverlay);

      // 裏面オーバーレイの存在確認
      if (!backOverlay) {
        console.log("iPhone Debug - ERROR: backOverlay element not found!");
      } else {
        console.log("iPhone Debug - backOverlay found, setting up events...");
      }

      // タッチイベント（タッチデバイスの場合）
      if (isTouchDevice) {
        console.log("iPhone Debug - Setting up touch events for back overlay...");
        // タッチデバイス用の裏面オーバーレイ処理
        let overlayTouchStartTime = 0;
        let overlayTouchStartY = 0;

        // より確実なタッチイベント設定
        backOverlay?.addEventListener(
          "touchstart",
          (e) => {
            console.log("iPhone Debug - Back overlay touch start detected (simplified)");
            console.log("iPhone Debug - Touch start event details:", e);
            console.log("iPhone Debug - Touch target:", e.target);
            console.log("iPhone Debug - Touch currentTarget:", e.currentTarget);
            overlayTouchStartTime = Date.now();

            // 即座にフリップを実行（タッチ開始時）
            console.log("iPhone Debug - Immediate flip on touch start");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backOverlay?.addEventListener(
          "touchend",
          (e) => {
            console.log("iPhone Debug - Back overlay touch end detected (simplified)");
            const touchDuration = Date.now() - overlayTouchStartTime;
            console.log("iPhone Debug - Back overlay touch duration:", touchDuration);

            // 即座にフリップを実行（タッチ終了時）
            console.log("iPhone Debug - Immediate flip on touch end");
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        // タッチキャンセル（追加）
        backOverlay?.addEventListener(
          "touchcancel",
          (e) => {
            console.log("iPhone Debug - Back overlay touch cancelled");
            console.log("iPhone Debug - Immediate flip on touch cancel");
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );
      }

      // クリックイベント（全てのデバイスで設定）
      backOverlay?.addEventListener("click", (e) => {
        console.log("iPhone Debug - Click event detected on back overlay");
        console.log("iPhone Debug - Click event details:", e);
        e.preventDefault();
        e.stopPropagation();
        handleBackClick(e);
      });

      // より直接的なアプローチ：裏面オーバーレイに直接的なタッチハンドラーを追加
      if (backOverlay) {
        console.log("iPhone Debug - Adding direct touch handler to back overlay");

        // 直接的なタッチイベント
        backOverlay.ontouchstart = (e) => {
          console.log("iPhone Debug - Direct touchstart on back overlay");
          e.preventDefault();
          handleBackClick(e);
        };

        backOverlay.onclick = (e) => {
          console.log("iPhone Debug - Direct click on back overlay");
          e.preventDefault();
          handleBackClick(e);
        };

        // より確実な方法：addEventListener で複数のイベントを同時に設定
        backOverlay.addEventListener(
          "touchstart",
          (e) => {
            console.log("iPhone Debug - addEventListener touchstart on back overlay");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backOverlay.addEventListener(
          "touchend",
          (e) => {
            console.log("iPhone Debug - addEventListener touchend on back overlay");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backOverlay.addEventListener(
          "click",
          (e) => {
            console.log("iPhone Debug - addEventListener click on back overlay");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        // さらに確実な方法：pointer events も追加
        backOverlay.addEventListener(
          "pointerdown",
          (e) => {
            console.log("iPhone Debug - addEventListener pointerdown on back overlay");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backOverlay.addEventListener(
          "pointerup",
          (e) => {
            console.log("iPhone Debug - addEventListener pointerup on back overlay");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );
      }

      // 追加のイベントハンドラー（タッチイベントの代替）
      backOverlay?.addEventListener("mousedown", (e) => {
        console.log("iPhone Debug - Mouse down detected on back overlay");
        handleBackClick(e);
      });

      backOverlay?.addEventListener("mouseup", (e) => {
        console.log("iPhone Debug - Mouse up detected on back overlay");
        handleBackClick(e);
      });

      // より確実なイベントハンドラー（pointer events）
      backOverlay?.addEventListener("pointerdown", (e) => {
        console.log("iPhone Debug - Pointer down detected on back overlay");
        handleBackClick(e);
      });

      backOverlay?.addEventListener("pointerup", (e) => {
        console.log("iPhone Debug - Pointer up detected on back overlay");
        handleBackClick(e);
      });

      // フォールバック: 裏面全体にもイベントを追加（より確実にするため）
      console.log("iPhone Debug - Setting up fallback events for back face");
      console.log("iPhone Debug - Back face element:", backFace);

      // 裏面全体の存在確認
      if (!backFace) {
        console.log("iPhone Debug - ERROR: backFace element not found!");
      } else {
        console.log("iPhone Debug - backFace found, setting up fallback events...");
      }

      // タッチイベント（タッチデバイスの場合）
      if (isTouchDevice) {
        console.log("iPhone Debug - Setting up touch events for back face...");
        // タッチデバイス用の裏面全体処理
        let backFaceTouchStartTime = 0;
        let backFaceTouchStartY = 0;

        // より確実なタッチイベント設定
        backFace?.addEventListener(
          "touchstart",
          (e) => {
            console.log("iPhone Debug - Back face touch start detected");
            console.log("iPhone Debug - Back face touch start event details:", e);
            console.log("iPhone Debug - Back face touch target:", e.target);
            console.log("iPhone Debug - Back face touch currentTarget:", e.currentTarget);
            const touch = e.touches[0];
            backFaceTouchStartTime = Date.now();
            backFaceTouchStartY = touch.clientY;

            // 即座にフリップを実行（タッチ開始時）
            console.log("iPhone Debug - Immediate flip on back face touch start");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backFace?.addEventListener(
          "touchend",
          (e) => {
            console.log("iPhone Debug - Back face touch end detected");
            const touchDuration = Date.now() - backFaceTouchStartTime;
            const touch = e.changedTouches[0];
            const touchEndY = touch.clientY;
            const touchDistance = Math.abs(touchEndY - backFaceTouchStartY);

            console.log(
              "iPhone Debug - Back face touch details - duration:",
              touchDuration,
              "distance:",
              touchDistance
            );

            // 即座にフリップを実行（タッチ終了時）
            console.log("iPhone Debug - Immediate flip on back face touch end");
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        // タッチキャンセル（追加）
        backFace?.addEventListener(
          "touchcancel",
          (e) => {
            console.log("iPhone Debug - Back face touch cancelled");
            console.log("iPhone Debug - Immediate flip on back face touch cancel");
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );
      }

      // クリックイベント（全てのデバイスで設定）
      backFace?.addEventListener("click", (e) => {
        console.log("iPhone Debug - Click event detected on back face");
        console.log("iPhone Debug - Back face click event details:", e);
        handleBackClick(e);
      });

      // より直接的なアプローチ：裏面全体に直接的なタッチハンドラーを追加
      if (backFace) {
        console.log("iPhone Debug - Adding direct touch handler to back face");

        // 直接的なタッチイベント
        backFace.ontouchstart = (e) => {
          console.log("iPhone Debug - Direct touchstart on back face");
          e.preventDefault();
          handleBackClick(e);
        };

        backFace.onclick = (e) => {
          console.log("iPhone Debug - Direct click on back face");
          e.preventDefault();
          handleBackClick(e);
        };

        // より確実な方法：addEventListener で複数のイベントを同時に設定
        backFace.addEventListener(
          "touchstart",
          (e) => {
            console.log("iPhone Debug - addEventListener touchstart on back face");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backFace.addEventListener(
          "touchend",
          (e) => {
            console.log("iPhone Debug - addEventListener touchend on back face");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backFace.addEventListener(
          "click",
          (e) => {
            console.log("iPhone Debug - addEventListener click on back face");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        // さらに確実な方法：pointer events も追加
        backFace.addEventListener(
          "pointerdown",
          (e) => {
            console.log("iPhone Debug - addEventListener pointerdown on back face");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );

        backFace.addEventListener(
          "pointerup",
          (e) => {
            console.log("iPhone Debug - addEventListener pointerup on back face");
            e.preventDefault();
            e.stopPropagation();
            handleBackClick(e);
          },
          { passive: false, capture: true }
        );
      }

      // 追加のイベントハンドラー（タッチイベントの代替）
      backFace?.addEventListener("mousedown", (e) => {
        console.log("iPhone Debug - Mouse down detected on back face");
        handleBackClick(e);
      });

      backFace?.addEventListener("mouseup", (e) => {
        console.log("iPhone Debug - Mouse up detected on back face");
        handleBackClick(e);
      });

      // より確実なイベントハンドラー（pointer events）
      backFace?.addEventListener("pointerdown", (e) => {
        console.log("iPhone Debug - Pointer down detected on back face");
        handleBackClick(e);
      });

      backFace?.addEventListener("pointerup", (e) => {
        console.log("iPhone Debug - Pointer up detected on back face");
        handleBackClick(e);
      });

      // フリップ状態の更新を監視
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "attributes" && mutation.attributeName === "class") {
            // フリップ状態はアニメーション完了後にリセットされるため、ここでは更新しない

            // 裏面が表示された時にイベントを再設定
            if (flipContainer?.classList.contains("flipped")) {
              console.log("iPhone Debug - Back face is now visible, re-setting up events...");

              // 裏面オーバーレイのイベントを再設定
              if (backOverlay) {
                console.log("iPhone Debug - Re-setting up back overlay events");

                // 直接的なタッチハンドラーを再設定
                backOverlay.ontouchstart = (e) => {
                  console.log("iPhone Debug - Re-setup direct touchstart on back overlay");
                  e.preventDefault();
                  handleBackClick(e);
                };

                backOverlay.onclick = (e) => {
                  console.log("iPhone Debug - Re-setup direct click on back overlay");
                  e.preventDefault();
                  handleBackClick(e);
                };

                // より確実な方法：addEventListener で複数のイベントを同時に再設定
                backOverlay.addEventListener(
                  "touchstart",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener touchstart on back overlay");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                backOverlay.addEventListener(
                  "touchend",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener touchend on back overlay");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                backOverlay.addEventListener(
                  "click",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener click on back overlay");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                // さらに確実な方法：pointer events も再設定
                backOverlay.addEventListener(
                  "pointerdown",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener pointerdown on back overlay");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                backOverlay.addEventListener(
                  "pointerup",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener pointerup on back overlay");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );
              }

              // 裏面全体のイベントを再設定
              if (backFace) {
                console.log("iPhone Debug - Re-setting up back face events");

                // 直接的なタッチハンドラーを再設定
                backFace.ontouchstart = (e) => {
                  console.log("iPhone Debug - Re-setup direct touchstart on back face");
                  e.preventDefault();
                  handleBackClick(e);
                };

                backFace.onclick = (e) => {
                  console.log("iPhone Debug - Re-setup direct click on back face");
                  e.preventDefault();
                  handleBackClick(e);
                };

                // より確実な方法：addEventListener で複数のイベントを同時に再設定
                backFace.addEventListener(
                  "touchstart",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener touchstart on back face");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                backFace.addEventListener(
                  "touchend",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener touchend on back face");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                backFace.addEventListener(
                  "click",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener click on back face");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                // さらに確実な方法：pointer events も再設定
                backFace.addEventListener(
                  "pointerdown",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener pointerdown on back face");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );

                backFace.addEventListener(
                  "pointerup",
                  (e) => {
                    console.log("iPhone Debug - Re-setup addEventListener pointerup on back face");
                    e.preventDefault();
                    e.stopPropagation();
                    handleBackClick(e);
                  },
                  { passive: false, capture: true }
                );
              }
            }
          }
        });
      });

      if (flipContainer) {
        observer.observe(flipContainer, { attributes: true });
        // 初期状態を設定（フリップ中ではない）
        updateFlipState(false);
      }

      // カードをフリップする関数（cards.forEach内で定義）
      function flipCard(container: HTMLElement | null, toFlipped: boolean, resetCallback?: () => void) {
        if (!container) {
          console.log("iPhone Debug - flipCard: container is null");
          return;
        }

        console.log("iPhone Debug - flipCard called with toFlipped:", toFlipped);

        // フリップ状態を内部状態で確認
        const isCurrentlyFlipped = isCurrentlyShowingBack;
        console.log("iPhone Debug - flipCard using internal state - isCurrentlyShowingBack:", isCurrentlyShowingBack);

        console.log("iPhone Debug - Current flipped state:", isCurrentlyFlipped);

        // 既に目的の状態の場合は何もしない
        if ((toFlipped && isCurrentlyFlipped) || (!toFlipped && !isCurrentlyFlipped)) {
          console.log("iPhone Debug - Already in target state, skipping flip");
          if (resetCallback) {
            resetCallback();
          }
          return;
        }

        // パフォーマンス最適化のためのwill-change設定
        container.style.willChange = "transform";

        // デバイス検出
        const isMobile = window.innerWidth <= 768;
        const isIOS = /iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase());
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

        // モバイルデバイス用の最適化設定
        if (isMobile || isIOS || isSafari) {
          container.style.webkitBackfaceVisibility = "hidden";
          container.style.backfaceVisibility = "hidden";
          container.style.webkitTransformStyle = "preserve-3d";
          container.style.transformStyle = "preserve-3d";

          // 表面と裏面にも強制的に設定
          const front = container.querySelector(".card__front") as HTMLElement;
          const back = container.querySelector(".card__back") as HTMLElement;

          if (front) {
            front.style.webkitBackfaceVisibility = "hidden";
            front.style.backfaceVisibility = "hidden";
            front.style.webkitTransformStyle = "preserve-3d";
            front.style.transformStyle = "preserve-3d";
          }

          if (back) {
            back.style.webkitBackfaceVisibility = "hidden";
            back.style.backfaceVisibility = "hidden";
            back.style.webkitTransformStyle = "preserve-3d";
            back.style.transformStyle = "preserve-3d";
          }
        }

        // アニメーション設定
        const animationConfig = {
          duration: isMobile ? 0.25 : 0.4,
          ease: "power2.inOut",
          force3D: true,
          onStart: () => {
            console.log("iPhone Debug - Animation started, toFlipped:", toFlipped);

            // アニメーション開始時にクラスを即座に適用
            if (toFlipped) {
              container.classList.add("flipped");
              console.log("iPhone Debug - Added flipped class");
            } else {
              container.classList.remove("flipped");
              console.log("iPhone Debug - Removed flipped class");
            }
          },
          onComplete: () => {
            console.log("iPhone Debug - Animation completed, toFlipped:", toFlipped);
            container.style.willChange = "auto";

            // アニメーション完了後に状態を確認
            if (toFlipped) {
              container.classList.add("flipped");
              console.log("iPhone Debug - Ensured flipped class is present");
            } else {
              container.classList.remove("flipped");
              console.log("iPhone Debug - Ensured flipped class is removed");
            }

            // フリップ状態をリセット（アニメーション完了後）
            setTimeout(() => {
              console.log("iPhone Debug - Resetting flip state after animation completion");
              // 独自のフリップ状態を更新
              if (toFlipped) {
                isCurrentlyShowingBack = true;
                console.log("iPhone Debug - Set isCurrentlyShowingBack to true");
              } else {
                isCurrentlyShowingBack = false;
                console.log("iPhone Debug - Set isCurrentlyShowingBack to false");
              }
              if (resetCallback) {
                resetCallback();
              }
            }, 100);
          },
        };

        // フリップアニメーション実行
        if (toFlipped) {
          console.log("iPhone Debug - Starting flip to back (180 degrees)");
          gsap.to(container, {
            ...animationConfig,
            rotationY: 180,
          });
        } else {
          console.log("iPhone Debug - Starting flip to front (0 degrees)");
          gsap.to(container, {
            ...animationConfig,
            rotationY: 0,
          });
        }
      }
    }); // cards.forEach の終了
  }

  // モダンな初期化方法
  function initializeCardFlip() {
    // カードが存在するかチェック
    const cards = document.querySelectorAll(".card__item");
    if (cards.length === 0) {
      return;
    }

    // 既に初期化済みの場合はスキップ
    const uninitializedCards = Array.from(cards).filter((card) => !card.hasAttribute("data-initialized"));

    if (uninitializedCards.length === 0) {
      return;
    }

    // 初期化を実行
    initCardFlip();

    // 初期化済みマークを追加
    cards.forEach((card) => {
      card.setAttribute("data-initialized", "true");
    });
  }

  // 初期化を実行する関数
  function runInitialization() {
    if (typeof window === "undefined") return;

    // 単一のタイミングで初期化を実行
    setTimeout(() => {
      initializeCardFlip();
    }, 100);

    // リサイズイベントでも初期化を再実行（必要に応じて）
    let resizeTimeout: number;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        initializeCardFlip();
      }, 250);
    });
  }

  // DOMが読み込まれた後に初期化
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", runInitialization);
  } else {
    // 既に読み込み完了している場合
    runInitialization();
  }

  // Astroの場合は、コンポーネントがマウントされた後に初期化
  if (typeof window !== "undefined") {
    runInitialization();
  }
</script>
