---

---

<link rel="stylesheet" href="/css/pagefind-ui.css" media="print" />

<div id="search"></div>

<style>
  #search {
    width: 100%;
    height: auto;
    min-height: 14vh; /* Clock.astroと同じ高さ基準 */
    background: var(--color-white);
    border-radius: 1rem;
    border: var(--color-gray) 1px solid;
    transition-duration: 300ms;
    position: relative; /* Clock.astroと同じposition設定 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 0.5rem; /* Clock.astroと同じパディング */
    box-sizing: border-box; /* Clock.astroと同じボックスサイズ */
  }

  @media (width <= 480px) {
    #search {
      min-height: 12vh; /* モバイル版のClock.astroと同じ高さ */
      padding: 0.25rem; /* Clock.astroと同じパディング */
    }
  }

  /* iPhone特有の調整 */
  @media (width <= 480px) and (-webkit-min-device-pixel-ratio: 2) {
    #search {
      min-height: 14vh; /* iPhone版のClock.astroと同じ高さ */
      padding: 0.25rem;
    }
  }

  /* Pagefind UIの検索ボックスのスタイル調整 */
  #search .pagefind-ui__search-input {
    font-size: 1rem;
    padding: 0.75rem;
    border-radius: 0.5rem;
    width: 100%;
    max-width: 400px; /* 最大幅を制限 */
  }

  /* PagefindUIが初期化された後も、検索コンテナの基本スタイルを維持 */
  #search .pagefind-ui {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  /* 検索結果が表示されていない状態でも、検索コンテナのスタイルを維持 */
  #search .pagefind-ui__search-input-wrapper {
    width: 100%;
    max-width: 400px;
    display: flex;
    justify-content: center;
  }

  @media (width <= 480px) {
    #search .pagefind-ui__search-input {
      font-size: 0.9rem; /* モバイルでは少し小さく */
      max-width: 100%; /* モバイルでは全幅使用 */
      margin: 0 auto; /* 中央配置 */
      padding: 0.5rem;
      border: 1px solid var(--color-aqua) !important;
    }

    /* スマホサイズでのPagefind UIのコンテナ全体を中央配置 */
    #search .pagefind-ui {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
  }

  /* JavaScriptで制御する最小限のスタイル調整用クラス */
  #search.pagefind-ready .pagefind-ui {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
</style>

<script>
  import { PagefindUI } from "@pagefind/default-ui";

  // CSSの遅延読み込み: requestIdleCallbackが利用可能な場合はそれを使用、そうでなければsetTimeout
  const loadPagefindCSS = () => {
    const link = document.querySelector('link[href="/css/pagefind-ui.css"]') as HTMLLinkElement;
    if (link && link.media === "print") {
      // まだ読み込まれていない場合のみ読み込む
      link.media = "all";
    }
  };

  // 初回読み込み時のみ遅延読み込み
  // View Transitions後は即座に読み込む必要があるため、別途処理
  const isInitialLoad = !(window as any).__pagefindCSSLoaded;
  if (isInitialLoad) {
    (window as any).__pagefindCSSLoaded = true;
    if ("requestIdleCallback" in window) {
      requestIdleCallback(loadPagefindCSS, { timeout: 2000 });
    } else {
      setTimeout(loadPagefindCSS, 1000);
    }
  } else {
    // View Transitions後は即座に読み込む
    loadPagefindCSS();
  }

  let pagefindUIInstance: PagefindUI | null = null;
  let mutationObserver: MutationObserver | null = null;
  let resizeHandler: (() => void) | null = null;

  // iPhone判定のヘルパー関数
  const isIPhone = (): boolean => {
    return window.innerWidth <= 480 && window.devicePixelRatio >= 2;
  };

  // スタイル更新用のインターフェース
  interface StyleUpdates {
    searchContainer?: {
      minHeight?: string;
      padding?: string;
      addReadyClass?: boolean;
    };
    pagefindUI?: {
      width?: string;
      display?: string;
      flexDirection?: string;
      alignItems?: string;
      justifyContent?: string;
    };
    searchInput?: {
      border?: string;
      borderColor?: string;
      removeBorder?: boolean;
    };
  }

  // すべてのDOM要素を一度に読み取る（読み取りフェーズ）
  const readDOMState = (): {
    searchContainer: HTMLElement | null;
    pagefindUI: HTMLElement | null;
    searchInput: HTMLInputElement | null;
    windowWidth: number;
    isSmallScreen: boolean;
    isIPhoneDevice: boolean;
  } => {
    const windowWidth = window.innerWidth;
    const isSmallScreen = windowWidth <= 480;
    const isIPhoneDevice = isIPhone();

    return {
      searchContainer: document.querySelector("#search") as HTMLElement | null,
      pagefindUI: document.querySelector("#search .pagefind-ui") as HTMLElement | null,
      searchInput: document.querySelector("#search .pagefind-ui__search-input") as HTMLInputElement | null,
      windowWidth,
      isSmallScreen,
      isIPhoneDevice,
    };
  };

  // 必要なスタイル更新を計算（読み取りフェーズ）
  const calculateStyleUpdates = (state: ReturnType<typeof readDOMState>): StyleUpdates => {
    const updates: StyleUpdates = {};

    if (state.searchContainer) {
      // 基本スタイルはCSSで定義されているため、最小限の調整のみ
      const expectedMinHeight = state.isIPhoneDevice ? "14vh" : state.isSmallScreen ? "12vh" : "14vh";
      const expectedPadding = state.isSmallScreen ? "0.25rem" : "0.5rem";
      const currentMinHeight = state.searchContainer.style.minHeight;
      const currentPadding = state.searchContainer.style.padding;
      const hasReadyClass = state.searchContainer.classList.contains("pagefind-ready");

      // クラスベースの制御を優先
      if (!hasReadyClass && state.pagefindUI) {
        updates.searchContainer = {
          addReadyClass: true,
        };
      }

      // レスポンシブな調整が必要な場合のみ更新
      if (currentMinHeight !== expectedMinHeight || currentPadding !== expectedPadding) {
        updates.searchContainer = {
          ...updates.searchContainer,
          minHeight: currentMinHeight !== expectedMinHeight ? expectedMinHeight : undefined,
          padding: currentPadding !== expectedPadding ? expectedPadding : undefined,
        };
      }
    }

    // pagefindUIのスタイルはCSSクラスで制御するため、JavaScriptでの直接操作は最小限に
    // ただし、PagefindUIが動的に生成する要素に対しては必要に応じて調整
    if (state.pagefindUI && !state.searchContainer?.classList.contains("pagefind-ready")) {
      // クラスが追加されればCSSで制御されるため、ここでは最小限の確認のみ
      const requiredStyles = {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
      };

      const style = state.pagefindUI.style;
      const needsUpdate =
        style.width !== requiredStyles.width ||
        style.display !== requiredStyles.display ||
        style.flexDirection !== requiredStyles.flexDirection ||
        style.alignItems !== requiredStyles.alignItems ||
        style.justifyContent !== requiredStyles.justifyContent;

      if (needsUpdate) {
        updates.pagefindUI = requiredStyles;
      }
    }

    // 検索入力欄のborderはモバイルでのみ必要（CSSで定義されているが、動的要素のため調整が必要）
    if (state.searchInput) {
      const needsBorder = state.isSmallScreen;
      const currentBorder = state.searchInput.style.border;
      const hasBorder = currentBorder.includes("#00ffff") || currentBorder.includes("rgb(0, 255, 255)");

      if (needsBorder && !hasBorder) {
        updates.searchInput = {
          border: "1px solid #00ffff",
          borderColor: "#00ffff",
        };
      } else if (!needsBorder && hasBorder) {
        updates.searchInput = {
          removeBorder: true,
        };
      }
    }

    return updates;
  };

  // 計算された更新を一括で適用（書き込みフェーズ）
  const applyStyleUpdates = (
    state: ReturnType<typeof readDOMState>,
    updates: StyleUpdates
  ): void => {
    // すべての書き込みを一度に実行（リフローを最小化）
    if (updates.searchContainer && state.searchContainer) {
      // クラスベースの制御を優先（リフローを削減）
      if (updates.searchContainer.addReadyClass) {
        state.searchContainer.classList.add("pagefind-ready");
      }

      // レスポンシブな調整が必要な場合のみ更新
      if (updates.searchContainer.minHeight !== undefined) {
        state.searchContainer.style.minHeight = updates.searchContainer.minHeight;
      }
      if (updates.searchContainer.padding !== undefined) {
        state.searchContainer.style.padding = updates.searchContainer.padding;
      }
    }

    // pagefindUIのスタイルはクラス追加後はCSSで制御されるため、必要最小限のみ
    if (updates.pagefindUI && state.pagefindUI && !state.searchContainer?.classList.contains("pagefind-ready")) {
      const style = state.pagefindUI.style;
      if (updates.pagefindUI.width) style.width = updates.pagefindUI.width;
      if (updates.pagefindUI.display) style.display = updates.pagefindUI.display;
      if (updates.pagefindUI.flexDirection) style.flexDirection = updates.pagefindUI.flexDirection;
      if (updates.pagefindUI.alignItems) style.alignItems = updates.pagefindUI.alignItems;
      if (updates.pagefindUI.justifyContent) style.justifyContent = updates.pagefindUI.justifyContent;
    }

    // 検索入力欄のborder調整（動的要素のため必要）
    if (updates.searchInput && state.searchInput) {
      if (updates.searchInput.removeBorder) {
        state.searchInput.style.border = "";
        state.searchInput.style.borderColor = "";
        state.searchInput.style.removeProperty("border");
      } else if (updates.searchInput.border) {
        state.searchInput.style.setProperty("border", updates.searchInput.border, "important");
        state.searchInput.style.borderColor = updates.searchInput.borderColor || "";
      }
    }
  };

  // 読み取りと書き込みを分離したスタイル更新関数
  const updateStyles = (): void => {
    // フェーズ1: すべての読み取りを一度に実行
    const state = readDOMState();

    // フェーズ2: 必要な更新を計算
    const updates = calculateStyleUpdates(state);

    // 更新が必要な場合のみ書き込みを実行
    if (Object.keys(updates).length > 0) {
      // フェーズ3: すべての書き込みを一度に実行
      applyStyleUpdates(state, updates);
    }
  };

  function initSearch() {
    // #search要素が存在するかチェック
    const searchElement = document.querySelector("#search");
    if (!searchElement) {
      // 要素が存在しない場合は静かに終了（エラーを出力しない）
      return;
    }

    // CSSの読み込みを確実にする（View Transitions後も）
    loadPagefindCSS();

    // 既存のインスタンスを破棄
    if (pagefindUIInstance) {
      // PagefindUIにはdestroyメソッドがないため、要素をクリア
      if (searchElement) {
        searchElement.innerHTML = "";
      }
      pagefindUIInstance = null;
    }

    // 既存のMutationObserverを破棄
    if (mutationObserver) {
      mutationObserver.disconnect();
      mutationObserver = null;
    }

    // 既存のリサイズハンドラーを削除
    if (resizeHandler) {
      window.removeEventListener("resize", resizeHandler);
      resizeHandler = null;
    }

    // 検索コンテナの基本スタイルを先に適用（PagefindUI初期化前）
    updateStyles();

    // 新しいPagefindUIインスタンスを作成（エラーハンドリング付き）
    try {
      pagefindUIInstance = new PagefindUI({
        element: "#search",
        showImages: true,
      });
    } catch (error) {
      // PagefindUIの初期化に失敗した場合は静かに終了（エラーを出力しない）
      // 要素が存在しない、またはPagefindUIが利用できない場合など
      return;
    }

    // requestAnimationFrameでバッチ処理（メインスレッド処理の最適化）
    let rafScheduled = false;
    let pendingUpdate = false;
    const scheduleStyleUpdate = () => {
      if (rafScheduled) {
        pendingUpdate = true;
        return;
      }
      rafScheduled = true;
      requestAnimationFrame(() => {
        updateStyles();
        rafScheduled = false;
        // 待機中の更新があれば再スケジュール
        if (pendingUpdate) {
          pendingUpdate = false;
          scheduleStyleUpdate();
        }
      });
    };

    // PagefindUIのDOM生成を待つ（MutationObserverで効率的に監視）
    const searchContainer = document.querySelector("#search");
    if (searchContainer) {
      let checkCount = 0;
      const maxChecks = 5; // 最大チェック回数を5回に削減（不要な更新を削減）

      // MutationObserverでDOMの変更を監視（最適化: 必要な要素のみ監視）
      mutationObserver = new MutationObserver((mutations) => {
        // 検索入力欄が追加された場合のみ更新をスケジュール
        const hasRelevantChange = mutations.some((mutation) => {
          if (mutation.type === "childList") {
            return Array.from(mutation.addedNodes).some(
              (node) =>
                node.nodeType === Node.ELEMENT_NODE &&
                ((node as Element).classList.contains("pagefind-ui__search-input") ||
                  (node as Element).querySelector?.(".pagefind-ui__search-input"))
            );
          }
          return false;
        });

        if (hasRelevantChange) {
          checkCount++;
          if (checkCount <= maxChecks) {
            scheduleStyleUpdate();
          } else {
            // 最大チェック回数に達したら監視を停止
            mutationObserver?.disconnect();
            mutationObserver = null;
          }
        }
      });

      // 監視範囲を最適化: 子要素の追加のみ監視（attributes監視を削除）
      mutationObserver.observe(searchContainer, {
        childList: true,
        subtree: true,
      });

      // 初期スタイル適用（即座に1回）
      scheduleStyleUpdate();

      // フォールバック: 300ms後に最終確認（タイムアウトを短縮）
      setTimeout(() => {
        if (checkCount < maxChecks) {
          scheduleStyleUpdate();
        }
      }, 300);
    }

    // ウィンドウリサイズ時にスタイルを再適用（デバウンス付き）
    let resizeTimer: ReturnType<typeof setTimeout> | null = null;
    resizeHandler = () => {
      if (resizeTimer) {
        clearTimeout(resizeTimer);
      }
      resizeTimer = setTimeout(() => {
        scheduleStyleUpdate();
      }, 200); // デバウンス時間を200msに調整（リフロー削減のため）
    };
    window.addEventListener("resize", resizeHandler, { passive: true });
  }

  // DOMContentLoadedで初期化
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSearch);
  } else {
    initSearch();
  }

  // View Transitions対応: ページ遷移時に再初期化
  document.addEventListener("astro:after-swap", () => {
    // CSS読み込みを確実にするため、少し遅延してから初期化
    // DOMの更新とCSSの読み込み完了を待つ
    setTimeout(() => {
      initSearch();
    }, 0);
  });
</script>
