---
import HeadLayout from "./HeadLayout.astro";
import Header from "./Header.astro";
import Footer from "./Footer.astro";
import PageTopButton from "../components/PageTopButton.astro";
// クリティカルなフォントのみを読み込む（400のみ）
import "@fontsource/poppins/400.css";

interface Props {
  title: string;
  description: string;
  ogType: string;
  ogTitle: string;
  ogDescription: string;
  twitterTitle: string;
  twitterDescription: string;
  jsonLd?: string;
}

const { title, description, ogType, ogTitle, ogDescription, twitterTitle, twitterDescription, jsonLd } = Astro.props;

// Google Analytics設定
const GA_MEASUREMENT_ID: string | undefined =
  typeof import.meta.env.PUBLIC_GA_MEASUREMENT_ID === "string"
    ? import.meta.env.PUBLIC_GA_MEASUREMENT_ID
    : undefined;
const isDev: boolean = typeof import.meta.env.DEV === "boolean" ? import.meta.env.DEV : false;

// 開発環境またはMeasurement IDが未設定の場合はスクリプトを読み込まない
const shouldLoadGA: boolean =
  !isDev &&
  typeof GA_MEASUREMENT_ID === "string" &&
  GA_MEASUREMENT_ID !== "" &&
  GA_MEASUREMENT_ID !== "G-XXXXXXXXXX";
---

<!doctype html>
<html lang="ja">
  <HeadLayout
    title={title}
    description={description}
    ogType={ogType}
    ogTitle={ogTitle}
    ogDescription={ogDescription}
    twitterTitle={twitterTitle}
    twitterDescription={twitterDescription}
    jsonLd={jsonLd}
  >
    <slot name="head" slot="head" />
  </HeadLayout>
  <body>
    <div id="overlay-root"></div>
    <div id="outer-container">
      <Header />
      <main id="page-wrap">
        <slot />
      </main>
      <Footer />
    </div>
    <PageTopButton />

    <!-- GSAPとScrollTriggerは必要なページでのみ動的インポートで読み込む -->
    <!-- js-confettiは必要なページでのみ動的インポートで読み込む -->

    {/* Google Analytics デバイスごとの条件分岐による遅延読み込み */}
    {shouldLoadGA && typeof GA_MEASUREMENT_ID === "string" && (
      <script
        is:inline
        define:vars={{ GA_MEASUREMENT_ID: GA_MEASUREMENT_ID }}
      >
        (function () {
          "use strict";

          // 一度だけ実行されるようにフラグを設定
          let isLoaded = false;
          let timeoutId = null;
          let scrollEventListeners = [];

          /**
           * Google Analytics スクリプトを読み込む
           * 一度だけ実行される（isLoadedフラグで制御）
           */
          function loadGoogleAnalytics() {
            // 既に読み込み済み、または読み込み中の場合はスキップ
            if (isLoaded) {
              return;
            }

            // フラグを設定（重複実行を防止）
            isLoaded = true;

            // タイムアウトをクリア
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }

            // イベントリスナーを削除
            removeScrollListeners();

            // gtag.js スクリプトの読み込み
            const script = document.createElement("script");
            script.async = true;
            script.src = `https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`;
            script.onerror = function () {
              console.warn("[Google Analytics] スクリプトの読み込みに失敗しました");
            };

            // スクリプトが読み込まれた後の処理
            script.onload = function () {
              // dataLayerとgtag関数は既にheadタグで初期化済み
              // ここでは追加の設定があれば実行
              if (window.dataLayer && window.gtag) {
                // スクリプト読み込み完了を通知（既にheadタグで設定済みのため、ここでは不要）
                // 必要に応じて追加の設定をここに記述
              }
            };

            document.head.appendChild(script);
          }

          /**
           * スクロールイベントリスナーを削除
           */
          function removeScrollListeners() {
            scrollEventListeners.forEach(function (listener) {
              window.removeEventListener(listener.event, listener.handler, { passive: true });
            });
            scrollEventListeners = [];
          }

          /**
           * 画面幅を取得（リサイズにも対応）
           */
          function getScreenWidth() {
            return (
              window.innerWidth ||
              document.documentElement.clientWidth ||
              document.body.clientWidth ||
              0
            );
          }

          /**
           * デバイス判定と読み込み方法の条件分岐
           * メインスレッド処理の最適化: Intersection Observerを使用してビューポートに入ったときに読み込む
           */
          function initGoogleAnalytics() {
            const screenWidth = getScreenWidth();

            // メインスレッド処理の最適化: Intersection Observerを使用（スクロールイベントより効率的）
            if ("IntersectionObserver" in window) {
              // ビューポートの下部にマーカー要素を作成（スクロールしてこの要素が見えたら読み込む）
              const marker = document.createElement("div");
              marker.style.position = "absolute";
              marker.style.bottom = "200px"; // ビューポートの下部200px手前で読み込み開始
              marker.style.width = "1px";
              marker.style.height = "1px";
              marker.style.pointerEvents = "none";
              marker.style.visibility = "hidden";
              document.body.appendChild(marker);

              const observer = new IntersectionObserver(
                function (entries) {
                  const isVisible = entries.some(function (entry) {
                    return entry.isIntersecting;
                  });

                  if (isVisible && !isLoaded) {
                    observer.disconnect();
                    document.body.removeChild(marker);
                    loadGoogleAnalytics();
                  }
                },
                {
                  rootMargin: "200px 0px", // 200px手前で読み込み開始
                  threshold: 0.01,
                }
              );

              observer.observe(marker);

              // フォールバック: 10秒後に読み込む（念のため）
              timeoutId = setTimeout(function () {
                if (!isLoaded) {
                  observer.disconnect();
                  if (document.body.contains(marker)) {
                    document.body.removeChild(marker);
                  }
                  loadGoogleAnalytics();
                }
              }, 10000);
            }
            // フォールバック: Intersection Observerがサポートされていない場合
            else {
              // ①スマホ・タブレット（768px以下）：スクロール検知後に実行
              if (screenWidth <= 768) {
                const SCROLL_THRESHOLD = 50;
                let hasScrolled = false;

                function handleScroll() {
                  const scrollY = window.scrollY || document.documentElement.scrollTop || 0;

                  if (!hasScrolled && scrollY >= SCROLL_THRESHOLD) {
                    hasScrolled = true;
                    loadGoogleAnalytics();
                  }
                }

                const scrollHandler = { event: "scroll", handler: handleScroll };
                const wheelHandler = { event: "wheel", handler: handleScroll };
                const touchHandler = { event: "touchstart", handler: handleScroll };

                window.addEventListener("scroll", handleScroll, { passive: true });
                window.addEventListener("wheel", handleScroll, { passive: true });
                window.addEventListener("touchstart", handleScroll, { passive: true });

                scrollEventListeners.push(scrollHandler, wheelHandler, touchHandler);

                timeoutId = setTimeout(function () {
                  if (!isLoaded) {
                    loadGoogleAnalytics();
                  }
                }, 10000);

                const currentScrollY = window.scrollY || document.documentElement.scrollTop || 0;
                if (currentScrollY >= SCROLL_THRESHOLD) {
                  loadGoogleAnalytics();
                }
              }
              // ②パソコン（1024px以上）：requestIdleCallbackで遅延読み込み
              else if (screenWidth >= 1024) {
                if ("requestIdleCallback" in window) {
                  requestIdleCallback(
                    function () {
                      loadGoogleAnalytics();
                    },
                    { timeout: 5000 }
                  );
                } else {
                  if (document.readyState === "loading") {
                    document.addEventListener("DOMContentLoaded", function () {
                      loadGoogleAnalytics();
                    });
                  } else {
                    loadGoogleAnalytics();
                  }
                }

                timeoutId = setTimeout(function () {
                  if (!isLoaded) {
                    loadGoogleAnalytics();
                  }
                }, 10000);
              }
              // ③中間サイズ（769px-1023px）：スクロール検知後に実行
              else {
                const SCROLL_THRESHOLD = 50;
                let hasScrolled = false;

                function handleScroll() {
                  const scrollY = window.scrollY || document.documentElement.scrollTop || 0;

                  if (!hasScrolled && scrollY >= SCROLL_THRESHOLD) {
                    hasScrolled = true;
                    loadGoogleAnalytics();
                  }
                }

                const scrollHandler = { event: "scroll", handler: handleScroll };
                const wheelHandler = { event: "wheel", handler: handleScroll };
                const touchHandler = { event: "touchstart", handler: handleScroll };

                window.addEventListener("scroll", handleScroll, { passive: true });
                window.addEventListener("wheel", handleScroll, { passive: true });
                window.addEventListener("touchstart", handleScroll, { passive: true });

                scrollEventListeners.push(scrollHandler, wheelHandler, touchHandler);

                timeoutId = setTimeout(function () {
                  if (!isLoaded) {
                    loadGoogleAnalytics();
                  }
                }, 10000);

                const currentScrollY = window.scrollY || document.documentElement.scrollTop || 0;
                if (currentScrollY >= SCROLL_THRESHOLD) {
                  loadGoogleAnalytics();
                }
              }
            }
          }

          // 初期化実行
          initGoogleAnalytics();

          // リサイズ時の再判定（オプション：通常は不要だが、念のため）
          // 注意: リサイズ時に再実行すると重複読み込みの可能性があるため、コメントアウト
          // window.addEventListener('resize', function() {
          //   if (!isLoaded) {
          //     removeScrollListeners();
          //     if (timeoutId !== null) {
          //       clearTimeout(timeoutId);
          //       timeoutId = null;
          //     }
          //     initGoogleAnalytics();
          //   }
          // });
        })();
      </script>
    )}
  </body>
</html>
